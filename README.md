# Davis-Putnam-Logemann-Loveland (**DPLL**) Solver

## Purpose
The purpose of this project is to implement a DPLL algorithm in a **DPLL** solver object. The algorithm is used to find if a given proposition is satisfiable or unsatisfiable. See DPLL.md for more details on the DPLL algorithm and propositions.

## Usage
The solver imvolves the usage of three custom objects: **Literal**, **Clause**, and **DPLL**. Each has its own attributes and methods that contribute to the solver being able to process the objects and reach a conclusion.

### Literals
A **Literal** object is the most basic foundational tool of the solver. Each contains four attributes, along with methods to manipulate and access those attributes. The attributes consist of two states, a sign, and a variable. The variable is used to represent the **Literal**s which are all of a kind. The sign is used to signify if a **Literal** has been negated. The two states of a **Literal** are an internal state stored as the `status` attribute, and an external state stored as the `calculated_val` attribute; both are represented by boolean values or `None`. The internal state of **Literal**s with the a given variable are the same throughout a proposition, but their external states may differ. The external state of a **Literal** is calculated using the `sign` and `status` attributes. If the sign is positive, the external state of the **Literal** is the same as the internal state. If the sign is negative, the **Literal** has been negated and the external state is opposite of the internal state. The variable of a **Literal** is initialized with the object; it is recommended that the object be assigned to a name that is the same as its variable, e.g.
                    `a = **Literal**('a')`
                    `b = **Literal**('b')`
                    `foo = **Literal**('foo')` etc.
The status of a **Literal** may be set using the `set_status()` method, with the default argument being `True`. The sign of a **Literal** may be flipped using the `NOT()` method which serves the effect of negating the **Literal**. The `NOT()` method produces a new **Literal**, a copy which has the same variable and internal state, but with opposite sign. This is to avoid changing a proposition after the **Literal** has been added to it. The external state of the **Literal** is calculated automatically whenever changes are made to either the internal state or the sign and when the external state is accessed through `calculated_val`.

### Clauses
A **Clause** object consists of a list of **Literal** objects and an external state. Each **Clause** contains two attributes, along with methods to manipulate and access those attributes. The two attributes are a list of **Literal**s called `clause`, and an external state called `status`. The `status` attribute is a boolean value contributed to by the external states of each of the **Literal**s within the 'clause' attribute. The `status` is set each time new **Literal**s are introduced, and whenever it is accessed through the `get_status()` method. There are two ways to add a **Literal** to the **Clause**: the first is on initialization of the **Clause** e.g. `cl = Clause(a, b)`, or through the use of the `ADD()` method e.g. `cl.ADD(foo)`. Other **Clause** objects may be added to a **Clause** in the same way that a **Literal** is; each **Literal** within the added **Clause** is simply added individually. The `remove()` method returns a **Clause** object without the **Literal** given as an argument. The `NOT()` method returns a set consisting of the **Literal**s within the `**Clause**` attribute, each negated.
A negated **Clause** may not be added to another **Clause**. The immutability of the **Clause** object is to avoid changing a proposition as a side affect. The **Clause** class also contains many of the basic list methods such as `contains`, 'eq`, and an iterator through the `clause` attribute. 

### DPLL
A **DPLL** object consists of a list of **Literal** and/or **Clause** objects, and a dict of the variables in every **Literal** in the list of objects. Each **DPLL** contains two attributes, along with methods to manipulate and access those attributes. The two attributes are a list of **Literal**s and/or **Clause**s called `proposition`, and a dict of the variables within the `proposition` attribute, called `variables`. **Literal**s and **Clause**s may be added to the `proposition` attribute in two ways. The **DPLL** object may be initialized with **Literal**s and/or **Clause**s as arguments e.g. `dpll = DPLL(foo, cl)` which adds them to `proposition`, or they may be added to the **DPLL** object with the `ADD()` method e.g. `dpll.ADD(a)`. Each new **Literal** added, on its own or within a **Clause**, contributes its variable to the `variables` attribute, if it is not already conatained within. Negated **Clauses** can be added to the **DPLL** in the same two ways. **Literal**s and **Clause**s within the `proposition` attribute of a **DPLL** object are somewhat permanent in that they may be removed from the `proposition` attribute through the private `disregard()` method, but the variables they contain will remain in the `varibales` attribute. In order to fully remove a **Literal** or a **Clause**, the **DPLL** object must be reinitialized without the given objects. The main methods of a **DPLL** object are the `solve()` and `solve_for_variables()` methods. The `solve()` method uses the DPLL algorithm in order to find the satisfiability of its proposition; it returns 'sat' if it is satisfiable, and 'unsat' if it is unsatisfiable. This method uses the `unit_clause_hueristic()` and 'pure_clause_hueristic()' methods along with a built-in guess and check in order to assign values to the **Literal** variables; the `simplify()` method is then used to disregard the proper **Literal**s and **Clause**s according to their external values. See DPLL.md for more in-depth explanation of these processes. The value assignments are tracked using the `variables` attribute which may be returned with the proper assignments if the result of the `solve()` call is 'sat', using the `solve_for_variables()` method; otherwise the result of this method is `None`. The **DPLL** class also contains many of the basic list methods such as `contains`, `len`, and an iterator through the `clause` attribute. 


